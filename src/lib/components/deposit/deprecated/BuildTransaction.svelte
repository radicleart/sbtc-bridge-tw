<script lang="ts">
import { CONFIG } from '$lib/config';
import { onMount } from 'svelte';
import { goto } from "$app/navigation";
import { sbtcConfig } from '$stores/stores'
import type { SbtcConfig } from '$types/sbtc_config';
import Principal from "$lib/components/common/Principal.svelte";
import PegInAmount from "../PegInAmount.svelte";
import ScriptHashAddress from "../ScriptHashAddress.svelte";
import UTXOSelection from "$lib/components/common/UTXOSelection.svelte";
import { createEventDispatcher } from "svelte";
import PegInTransaction from '$lib/domain/PegInTransaction';
import type { PegInTransactionI } from '$lib/domain/PegInTransaction';
import { addresses } from '$lib/stacks_connect';
import { explorerBtcAddressUrl } from "$lib/utils";
import Modal from '$lib/components/shared/Modal.svelte';
import DebugPeginInfo from '$lib/components/common/DebugPeginInfo.svelte';
import { hex } from '@scure/base';
import { getTestAddresses, sbtcWallets } from 'sbtc-bridge-lib' 
import type { PeginRequestI, PegInData, CommitKeysI } from 'sbtc-bridge-lib' 

let piTx:PegInTransactionI;
let componentKey3 = 0;
const network = CONFIG.VITE_NETWORK;
const dispatch = createEventDispatcher();
let errorReason:string|undefined;
let stxAddressOk = true;
let amountOk = false;
let peginRequest:PeginRequestI;
let showModal:boolean;
let inited = false;
let custodialReclaim = false;
let allowPayWithWebWallet = false;

$: showStxAddress = true; //!errorReason;
$: showAmount = true; //stxAddressOk && !errorReason;
$: showButton = true; //piTx && !errorReason;
$: webWalletPayment = allowPayWithWebWallet && piTx && piTx.maxCommit() >= piTx.pegInData.amount;

const getExplorerUrl = () => {
  return explorerBtcAddressUrl(piTx.fromBtcAddress)
}

const principalData = {
  label: 'Stacks Address (Account or Contract)',
  info: 'sBTC will be minted to this account or contract',
  currentAddress: ''
}
const amtData = () => {
  return {
    pegIn: true,
    label: 'Amount (Satoshis)',
    info: '',
    pegAmount: piTx.pegInData.amount,
    maxCommit: piTx.maxCommit(),
    change: piTx.getChange(),
    fee: piTx.fee,
    fees: piTx.fees,
    dust: 500
  }
}

$: utxoData = {
  label: 'Return Bitcoin Address',
  info: 'Your BTC will be returned to this address if for any reason the sBTC does not materialize',
  utxos: [],
  maxCommit: 0,
  fromBtcAddress: '',
  numbInputs: 0,
  network
}

const updateConfig = () => {
  const conf:SbtcConfig = $sbtcConfig;
  conf.pegInTransaction = piTx;
  sbtcConfig.update(() => conf);
  //amountOk = piTx.pegInData?.amount > 0;
}

const amountUpdated = (event:any) => {
  errorReason = undefined;
  amountOk = !event.detail.error;
  if (event.detail.opCode === 'user') {
    try {
      piTx.setAmount(event.detail.newAmount)
    } catch (err:any) {
      errorReason = err;
      piTx.setAmount(piTx.maxCommit() - piTx.fee);
    }
  } else if (event.detail.opCode === 'prio') {
    piTx.setFeeRate(event.detail.newFeeRate)
    //if (piTx.pegInData.amount > piTx.maxCommit() - piTx.fee) piTx.setAmount(piTx.maxCommit() - piTx.fee)
  }
  updateConfig();
  componentKey3++;
}

const principalUpdated = (event:any) => {
  errorReason = undefined;
  stxAddressOk = !event.detail.error;
  if (stxAddressOk) {
    piTx.setStacksAddress(event.detail.currentAddress)
    updateConfig();
  }
}

const commitAddresses = ():CommitKeysI => {
  const addrs = addresses()
  const stacksAddress = (piTx && piTx.pegInData?.stacksAddress) ? piTx.pegInData?.stacksAddress : addrs.stxAddress;
  let fromBtcAddress = addrs.cardinal; //$sbtcConfig.peginRequest.fromBtcAddress || addrs.ordinal;
  let sbtcWalletAddress = $sbtcConfig.sbtcContractData.sbtcWalletAddress as string;
  const sbtcWallet = sbtcWallets.find((o) => o.sbtcAddress === sbtcWalletAddress);
  if (!sbtcWallet) throw new Error('No sBTC Wallet found for address: ' + sbtcWalletAddress)
  let testAddrs;
  if ($sbtcConfig.userSettings.testAddresses) {
    testAddrs = getTestAddresses(CONFIG.VITE_NETWORK);
  }
  //const xyWebWalletPubKey = hex.decode(addrs.btcPubkeySegwit1);
  //let xOnlyPubKey = hex.encode(xyWebWalletPubKey.subarray(1));
  //const net = (network === 'testnet') ? btc.TEST_NETWORK : btc.NETWORK;
  //const outTr = { type: 'tr', pubkey: hex.decode(addrs.btcPubkeySegwit1) }
  //const addrO = btc.Address(net).encode(outTr);
  //const addrScript = btc.Address(net).decode(addrs.ordinal);
  //if (addrScript.type !== 'tr') throw new Error('Expecting taproot address')
  //const xOnlyPubKey = hex.encode(addrScript.pubkey)
  return {
    fromBtcAddress,
    sbtcWalletAddress,
    revealPub: $sbtcConfig.keys.deposits.revealPubKey, //(testAddrs) ? testAddrs.revealPub : sbtcWallet.pubKey,
    reclaimPub: $sbtcConfig.keys.deposits.reclaimPubKey,
    stacksAddress
  }
}

const utxoUpdated = async (event:any) => {
  errorReason = undefined;
  const data:any = event.detail;
  if (data.opCode === 'address-change') {
    try {
      const p0 = piTx.pegInData;
      piTx.fromBtcAddress = data.bitcoinAddress;
      piTx = await PegInTransaction.create(network, commitAddresses());
      piTx.calculateFees();
      //piTx.setStacksAddress(commitAddresses().stacksAddress);
      if (p0.amount > 0 && p0.amount < piTx.maxCommit()) piTx.setAmount(p0.amount);
      updateConfig();
    } catch (err:any) {
      console.log(err)
      if ($sbtcConfig.userSettings.useOpDrop) {
        piTx.setAmount(0)
        updateConfig();
      } else {
        errorReason = 'Your address either has no balance or there are unconfirmed transactions. You can paste another address or check this address here <a href=' + getExplorerUrl() + ' target="_blank">btc explorer</a>'
      }
      //if (err.message !== 'No inputs signed') errorReason = err.message;
      //else errorReason = 'Please fix above errors and try again.'
    }
  }
}

const nextStep = (wallet:number) => {
  // 1: stacks web wallet, 2: any wallet
  errorReason = undefined;
  if (piTx.pegInData.amount === 0) {
    errorReason = 'Please enter the amount you want to deposit?'
    return
  }
  if (!stxAddressOk) {
    errorReason = 'Please enter a valid Stacks Address?'
    return
  }
  
  if (wallet === 1) {
    dispatch('request_signature', { wallet, piTx });
  } else {
    showModal = !showModal;
  }
}
const nextModal = () => {
  goto('/deposits');
}
const closeModal = () => {
  showModal = false;
}
const closeOnEscape = (e:any) => {
  if (e.key === 'Escape') {
    showModal = false;
  }
}

onMount(async () => {
  if ($sbtcConfig.pegInTransaction) {
    piTx = PegInTransaction.hydrate($sbtcConfig.pegInTransaction);
  } else {
    piTx = await PegInTransaction.create(network, commitAddresses());
  }
  if (!piTx.pegInData) piTx.pegInData = {} as PegInData;
  if (!piTx.pegInData.stacksAddress && addresses().stxAddress) piTx.pegInData.stacksAddress = addresses().stxAddress;
  if (piTx.pegInData.stacksAddress) stxAddressOk = true;
  if (piTx.pegInData.amount > 0) amountOk = true;
  piTx.pegInData.amount = (piTx.pegInData.amount > 0) ? piTx.pegInData.amount : 0;
  // (piTx.pegInData.amount) ? piTx.pegInData.amount : piTx.maxCommit() - piTx.fee

  principalData.currentAddress = piTx.pegInData.stacksAddress as string;

  utxoData.utxos = piTx.addressInfo.utxos;
  utxoData.maxCommit = (piTx.ready) ? piTx.maxCommit() : 0;
  utxoData.fromBtcAddress = (piTx.ready) ? piTx.fromBtcAddress : addresses().ordinal;
  utxoData.numbInputs = (piTx.ready) ? piTx.addressInfo.utxos.length : 0;

  try {
    peginRequest = piTx.getOpDropPeginRequest();
  } catch (err) {
    piTx.commitKeys = commitAddresses(); // make sure the addresses are all hex encoded and serialisation safe.
    peginRequest = piTx.getOpDropPeginRequest();
  }
  updateConfig();
  inited = true;
  document.addEventListener('keydown', closeOnEscape);
})


</script>
{#if showModal}
<Modal {showModal} on:click={closeModal} on:close_modal={closeModal}>
  <div class="mb-4"><ScriptHashAddress {piTx}/></div>
  <div slot="title"></div>
  <div slot="close" class="d-flex justify-content-around">
    <div class="text-center"><button class="btn btn-outline-info" on:click={closeModal}>CLOSE</button></div>
    <div class="text-center"><button class="btn btn-outline-info" on:click={nextModal}>NEXT</button></div>
  </div>
  <div slot="debug">
    <div class="row my-3 text-small">
      <div class="col-12">
        <DebugPeginInfo tx={piTx}/>
      </div>
    </div>    
  </div>
</Modal>
{/if}
{#if inited}
  {#if allowPayWithWebWallet}
  <div class="mb-4"><UTXOSelection {utxoData} on:utxo_updated={utxoUpdated} /></div>
  {/if}
  {#if showStxAddress}
  <div class="mb-4"><Principal {principalData} on:principal_updated={principalUpdated} /></div>
  {/if}
  {#if showAmount}
  {#key componentKey3}
  <div class="mb-4"><PegInAmount amtData={amtData()} on:amount_updated={amountUpdated} /></div>
  {/key}
  {/if}
  {#if errorReason}<div class="text-danger">{@html errorReason}</div>{/if}
  {#if custodialReclaim}
  <div class="mb-4 text-small">Note: refunds will be sent to the address you send the deposit from</div>
  {/if}

  {#if showButton}
  <div class="row">
    {#if webWalletPayment}
    <div class="col-6">
      <button class="btn btn-outline-info w-100" type="button" on:click={() => nextStep(1)}>Web Wallet</button>
    </div>
    {/if}
    <div class="col-6">
      <button class="btn btn-outline-info w-100" type="button" on:click={() => nextStep(2)}>Show Invoice</button>
    </div>
  </div>
  {/if}
{/if}

<style>
</style>